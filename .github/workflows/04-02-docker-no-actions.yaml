name: 04 - Docker Web CI

on:
  push:
    branches: [ docker ]
  pull_request:
    branches: [ docker ]
  workflow_dispatch:

# (opcjonalnie) ogranicz równoległe uruchomienia dla PR-ów
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-no-actions-test:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: CWICZENIA/04-praca-z-zewnetrzymi-akcjami/docker-app-02

    env:
      IMAGE_NAME: webapp
      TAG: ${{ github.sha }}
      HOST_PORT: 8080          # port na hoście (runner)
      CONTAINER_PORT: 80       # port w kontenerze, zmień jeśli w Twoim obrazie jest inny (np. 8080)

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Wersje narzędzi
        run: |
          set -euxo pipefail
          docker --version
          curl --version

      # (bez gotowych akcji) build obrazu z lokalnego Dockerfile
      - name: Build obrazu
        run: |
          set -euxo pipefail
          docker build \
            --pull \
            --tag "${IMAGE_NAME}:${TAG}" \
            .

      # pre-cleanup na wypadek kolizji nazw/portów
      - name: Pre-cleanup kontenera (jeśli istnieje)
        run: |
          set -euxo pipefail
          docker ps -a --format '{{.Names}}' | grep -q "^${IMAGE_NAME}$" && docker rm -f "${IMAGE_NAME}" || true
          # zwolnij port jeśli coś nasłuchuje
          sudo fuser -k "${HOST_PORT}/tcp" || true

      # uruchom kontener (port HOST:CONTAINER)
      - name: Run kontenera
        run: |
          set -euxo pipefail
          docker run -d --name "${IMAGE_NAME}" -p "${HOST_PORT}:${CONTAINER_PORT}" "${IMAGE_NAME}:${TAG}"
          docker ps

      # poczekaj aż zacznie odpowiadać HTTP i zweryfikuj status
      - name: Healthcheck HTTP
        run: |
          set -euxo pipefail
          URL="http://localhost:${HOST_PORT}/"
          echo "Sprawdzam ${URL}"

          # czekamy maks. ~30s aż serwer wstanie
          for i in $(seq 1 30); do
            if curl -fsS -o /dev/null "${URL}"; then
              echo "Serwis jest osiągalny."
              break
            fi
            echo "Brak odpowiedzi, próba $i/30..."
            sleep 1
          done

          # ostateczny, rygorystyczny test: kod 200 i minimalna treść (opcjonalnie)
          HTTP_CODE=$(curl -s -o /tmp/index.html -w "%{http_code}" "${URL}")
          echo "HTTP_CODE=${HTTP_CODE}"
          test "${HTTP_CODE}" = "200"
          # możesz też sprawdzić zawartość:
          # grep -Ei '(<html|<head|<body)' /tmp/index.html

      - name: Healthcheck HTTP 2
        run: |
          set -euxo pipefail
          URL="http://localhost:${HOST_PORT}/"
          for i in $(seq 1 30); do
            curl -fsS -o /tmp/index.html "${URL}" && break || true
            sleep 1
          done
          grep -F "cw04 github actions" /tmp/index.html
          # (opcjonalnie) sprawdź, czy obrazek serwuje się lokalnie:
          curl -fsS -I "${URL}assets/wall.jpg" | grep -E "^HTTP/.* 200"    

      # logi przy niepowodzeniu (zawsze)
      - name: Zrzut logów kontenera (always)
        if: always()
        run: |
          set +e
          echo "---- docker logs ${IMAGE_NAME} ----"
          docker logs "${IMAGE_NAME}" || true
          echo "-----------------------------------"

      # sprzątanie (zawsze)
      - name: Cleanup (always)
        if: always()
        run: |
          set -euxo pipefail
          docker rm -f "${IMAGE_NAME}" || true
          docker image rm "${IMAGE_NAME}:${TAG}" || true

  build-with-actions-test:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: CWICZENIA/04-praca-z-zewnetrzymi-akcjami/docker-app-02

    env:
      IMAGE_NAME: webapp
      TAG: ${{ github.sha }}
      HOST_PORT: 8080
      CONTAINER_PORT: 80

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Setup Docker Buildx (builder dla docker/build-push-action)
      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3

      # (opcjonalnie) wygeneruj metadane tagów — nie jest wymagane,
      # ale pokazuję dla porządku. Używamy TAG = sha.
      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ env.TAG }}

      # Build obrazu lokalnie i "załaduj" go do demona Dockera na runnerze (load: true)
      - name: Build image (local)
        uses: docker/build-push-action@v6
        with:
          context: ${{ github.workspace }}/CWICZENIA/04-praca-z-zewnetrzymi-akcjami/docker-app-02
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:${{ env.TAG }}

      # Uruchom usługę przez Compose (zbuduje ponownie jeśli trzeba i podniesie kontener)
      - name: Compose up
        uses: docker/compose-action@v3
        with:
          compose-file: ${{ github.workspace }}/CWICZENIA/04-praca-z-zewnetrzymi-akcjami/docker-app-02/docker-compose.yml
          # --build dla pewności, -d w tle
          run: up -d --build

      # Sprawdź, czy endpoint odpowiada (HTTP 2xx/3xx). Ma retry.
      - name: URL Health Check
        uses: jtalk/url-health-check-action@v3
        with:
          url: http://localhost:${{ env.HOST_PORT }}/
          max-attempts: 30
          retry-delay: 1s
          follow-redirect: false
          exclude-regex: ""   # nic nie wykluczamy

      # Pobierz stronę i udostępnij body w outputach kroku
      - name: GET /
        id: page
        uses: Satak/webrequest-action@v1.2.4
        with:
          url: http://localhost:${{ env.HOST_PORT }}/
          method: GET

      # Asercja treści: oczekujemy "cw04 github actions"
      - name: Assert page contains expected text
        uses: actions/github-script@v7
        with:
          script: |
            const body = `${{ steps.page.outputs.output }}`;
            if (!body.includes('cw04 github actions')) {
              core.setFailed('Strona nie zawiera oczekiwanego napisu: "cw04 github actions".');
            }

      # Sprawdź serwowanie obrazka (status 200)
      - name: GET /assets/wall.jpg
        id: img
        uses: fjogeleit/http-request-action@v1
        with:
          url: http://localhost:${{ env.HOST_PORT }}/assets/wall.jpg
          method: GET
          timeout: 30000

      - name: Assert image 200
        uses: actions/github-script@v7
        with:
          script: |
            const status = Number(`${{ steps.img.outputs.status }}`);
            if (status !== 200) {
              core.setFailed(`Obrazek nie jest dostępny (HTTP ${status}).`);
            }
            const ctype = `${{ steps.img.outputs.headers }}`
              .toLowerCase();
            // nagłówki są serializowane; prosty check
            if (!ctype.includes('image') && !ctype.includes('jpeg') && !ctype.includes('jpg')) {
              core.warning('Content-Type nie wygląda na obrazek JPEG.');
            }

      # Zrzut logów kontenera (zawsze)
      - name: Docker logs (always)
        if: always()
        uses: jwalton/gh-docker-logs-action@v2
        with:
          containers: ${{ env.IMAGE_NAME }}

      # Sprzątanie (zawsze): compose down + usunięcie sieci/wolumenów/sierot
      - name: Compose down (always)
        if: always()
        uses: docker/compose-action@v3
        with:
          compose-file: ${{ github.workspace }}/CWICZENIA/04-praca-z-zewnetrzymi-akcjami/docker-app-02/docker-compose.yml
          run: down --volumes --remove-orphans
