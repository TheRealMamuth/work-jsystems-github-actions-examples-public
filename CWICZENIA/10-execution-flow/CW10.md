# Practical Exercise 11 – Defining Dependencies & Executing Jobs Conditionally / Ćwiczenie praktyczne 11 – Definiowanie zależności i warunkowe uruchamianie jobów

## English

### Exercise Description
In this practical exercise, our goal is to explore in detail how to define dependencies between jobs, as well as how to execute jobs conditionally and how to continue the execution despite failures.

Here are the instructions for the exercise:

1. Create a file named `10-execution-flow.yaml` under the `.github/workflows` folder at the root of your repository.
2. Name the workflow `10 – Controlling the Execution Flow`.
3. Add the following triggers with event filters and activity types to your workflow:
   - a. `workflow_dispatch`: the `workflow_dispatch` trigger should receive a single input named `pass-unit-tests`, of type `boolean` and with a default value of `false`.
4. This workflow will contain six jobs:
   - a. **The first job:**
     - i. Should be named `lint-build`  
     - ii. Should execute on `ubuntu-latest`  
     - iii. Should contain a single step named `Lint and build` that prints the following message: `"Linting and building project"`
   - b. **The second job:**
     - i. Should be named `unit-tests`  
     - ii. Should execute on `ubuntu-latest`  
     - iii. Should contain two steps:  
       -  i. The first step, named `Running unit tests`, should print the following message: `"Running tests..."`  
       -  ii. The second step, named `Failing tests`, should exit with a non-zero code and it should execute if and only if the input `pass-unit-tests` is set to `false`.
   - c. **The third job:**
     - i. Should be named `deploy-nonprod`  
     - ii. Should execute on `ubuntu-latest`  
     - iii. Should execute only after both the `lint-build` and the `unit-tests` jobs successfully complete  
     - iv. Should contain a single step named `Deploying to nonprod` that prints the following message: `"Deploying to nonprod..."`
   - d. **The fourth job:**
     - i. Should be named `e2e-tests`  
     - ii. Should execute on `ubuntu-latest`  
     - iii. Should execute only after the `deploy-nonprod` job successfully completes  
     - iv. Should contain a single step named `Running E2E tests` that prints the following message: `"Running E2E tests"`
   - e. **The fifth job:**
     - i. Should be named `load-tests`  
     - ii. Should execute on `ubuntu-latest`  
     - iii. Should execute only after the `deploy-nonprod` job successfully completes  
     - iv. Should contain a single step named `Running load tests` that prints the following message: `"Running load tests"`
   - f. **The sixth job:**
     - i. Should be named `deploy-prod`  
     - ii. Should execute on `ubuntu-latest`  
     - iii. Should execute only after both the `e2e-tests` and `load-tests` jobs successfully complete  
     - iv. Should contain a single step named `Deploying to prod` that prints the following message: `"Deploying to prod..."`
5. Commit the changes and push the code. Trigger the workflow from the UI, providing varying values for the `pass-unit-tests` input. Take a few moments to inspect the output of the workflow runs. How did the failing of a single job impact downstream dependent jobs?
6. Now modify the `unit-tests` job to allow the continuation of the workflow even if this specific job fails. This can be done by adding `continue-on-error: true` at the job definition level.
7. Commit the changes and push the code. Trigger the workflow from the UI, providing varying values for the `pass-unit-tests` input. Take a few moments to inspect the output of the workflow runs. How did the failing of a single job impact downstream dependent jobs?
8. `continue-on-error` should be used sparingly, only if there is a specific use-case for it (for example, experimental features). Remove the `continue-on-error` option from the job definition, commit the changes and push the code.

---

## Polski

### Opis ćwiczenia
W tym ćwiczeniu naszym celem jest szczegółowe zbadanie, jak definiować zależności pomiędzy zadaniami (jobs), jak uruchamiać zadania warunkowo oraz jak kontynuować wykonanie mimo wystąpienia błędów.

Oto instrukcje do ćwiczenia:

1. Utwórz plik o nazwie `10-execution-flow.yaml` w folderze `.github/workflows` w katalogu głównym repozytorium.
2. Nazwij workflow `10 – Controlling the Execution Flow`.
3. Dodaj do workflow następujące wyzwalacze z filtrami zdarzeń i typami aktywności:
   - a. `workflow_dispatch`: wyzwalacz `workflow_dispatch` ma przyjmować pojedynczy input o nazwie `pass-unit-tests`, typu `boolean`, z domyślną wartością `false`.
4. Ten workflow będzie zawierał sześć jobów:
   - a. **Pierwszy job:**  
     - i. Powinien nazywać się `lint-build`  
     - ii. Powinien wykonywać się na `ubuntu-latest`  
     - iii. Powinien zawierać pojedynczy krok `Lint and build`, który wypisuje komunikat: `"Linting and building project"`
   - b. **Drugi job:**  
     - i. Powinien nazywać się `unit-tests`  
     - ii. Powinien wykonywać się na `ubuntu-latest`  
     - iii. Powinien zawierać dwa kroki:  
       -  i. Pierwszy krok, `Running unit tests`, powinien wypisać komunikat: `"Running tests..."`  
       -  ii. Drugi krok, `Failing tests`, powinien zakończyć się kodem innym niż zero i wykonać się wtedy i tylko wtedy, gdy input `pass-unit-tests` ma wartość `false`.
   c. **Trzeci job:**  
      - i. Powinien nazywać się `deploy-nonprod`  
      - ii. Powinien wykonywać się na `ubuntu-latest`  
      - iii. Powinien wykonać się dopiero po pomyślnym zakończeniu jobów `lint-build` i `unit-tests`  
      - iv. Powinien zawierać pojedynczy krok `Deploying to nonprod`, który wypisuje komunikat: `"Deploying to nonprod..."`
   d. **Czwarty job:**  
      - i. Powinien nazywać się `e2e-tests`  
      - ii. Powinien wykonywać się na `ubuntu-latest`  
      - iii. Powinien wykonać się dopiero po pomyślnym zakończeniu joba `deploy-nonprod`  
      - iv. Powinien zawierać pojedynczy krok `Running E2E tests`, który wypisuje komunikat: `"Running E2E tests"`
   e. **Piąty job:**  
      - i. Powinien nazywać się `load-tests`  
      - ii. Powinien wykonywać się na `ubuntu-latest`  
      - iii. Powinien wykonać się dopiero po pomyślnym zakończeniu joba `deploy-nonprod`  
      - iv. Powinien zawierać pojedynczy krok `Running load tests`, który wypisuje komunikat: `"Running load tests"`
   f. **Szósty job:**  
      - i. Powinien nazywać się `deploy-prod`  
      - ii. Powinien wykonywać się na `ubuntu-latest`  
      - iii. Powinien wykonać się dopiero po pomyślnym zakończeniu jobów `e2e-tests` i `load-tests`  
      - iv. Powinien zawierać pojedynczy krok `Deploying to prod`, który wypisuje komunikat: `"Deploying to prod..."`
5. Zacommituj zmiany i wypchnij kod. Uruchom workflow z UI, podając różne wartości dla inputu `pass-unit-tests`. Poświęć chwilę na przejrzenie wyników uruchomień. Jak niepowodzenie pojedynczego joba wpłynęło na zależne od niego, dalsze joby?
6. Zmodyfikuj teraz job `unit-tests`, aby umożliwić kontynuację workflow nawet wtedy, gdy ten konkretny job zakończy się błędem. Można to zrobić, dodając na poziomie definicji joba opcję `continue-on-error: true`.
7. Zacommituj zmiany i wypchnij kod. Uruchom workflow z UI, podając różne wartości dla inputu `pass-unit-tests`. Poświęć chwilę na przejrzenie wyników uruchomień. Jak niepowodzenie pojedynczego joba wpłynęło na zależne od niego joby?
8. Opcji `continue-on-error` należy używać oszczędnie, tylko jeśli istnieje konkretny przypadek użycia (np. funkcje eksperymentalne). Usuń `continue-on-error` z definicji joba, zacommituj zmiany i wypchnij kod.
